## C# バージョン別機能比較 (3.1 - 12)

C#は、Microsoftによって開発された汎用プログラミング言語であり、その進化の過程で多くの機能が追加されてきました。このドキュメントでは、C# 3.1からC# 12までの主な機能差と、それぞれのサンプルコードを比較します。

### C# 3.1 (2009)

* LINQ (Language Integrated Query)
* ラムダ式
* 拡張メソッド
* 匿名型
* 自動実装プロパティ
* オブジェクト初期化子
* コレクション初期化子
* 部分メソッド

```csharp
// LINQ
List<int> numbers = new List<int> { 1, 2, 3, 4, 5 };
var evenNumbers = from n in numbers
                  where n % 2 == 0
                  select n;

// ラムダ式
Func<int, int> square = x => x * x;

// 拡張メソッド
public static class StringExtensions
{
    public static int WordCount(this string str)
    {
        return str.Split(new char[] { ' ', '.', '?' }, StringSplitOptions.RemoveEmptyEntries).Length;
    }
}
string text = "Hello, world!";
int count = text.WordCount(); // 2

// 匿名型
var person = new { Name = "John", Age = 30 };

//自動実装プロパティ
public class MyClass
{
  public int MyProperty { get; set; }  //自動実装プロパティ
}

//オブジェクト初期化子
MyClass obj = new MyClass { MyProperty = 10 };

//コレクション初期化子
List<int> list = new List<int> { 1, 2, 3 };
```

### C# 4.0 (2010)
 * 動的バインディング (dynamic)
 * 名前付き引数と省略可能な引数
 * ジェネリック型の分散 (Variance)
 * COM相互運用性の向上
```csharp
// 動的バインディング
dynamic d = 10;
d.Hello(); // コンパイル時にはエラーにならないが、実行時にエラーになる可能性がある

// 名前付き引数と省略可能な引数
void MyMethod(int a, int b = 20, int c = 30) { /* ... */ }
MyMethod(10, c: 50); // a = 10, b = 20, c = 50

// ジェネリック型の分散
IEnumerable<string> strings = new List<string>();
IEnumerable<object> objects = strings; // 共変性 (out)
```

### C# 5.0 (2012)
 * async/await (非同期プログラミングのサポート)
 * Caller Information属性

```csharp
// async/await
async Task<string> GetWebPageContentAsync(string url)
{
    HttpClient client = new HttpClient();
    string content = await client.GetStringAsync(url);
    return content;
}

// Caller Information属性
void LogMessage(string message,
                 [CallerMemberName] string memberName = "",
                 [CallerFilePath] string sourceFilePath = "",
                 [CallerLineNumber] int sourceLineNumber = 0)
{
    Console.WriteLine($"{memberName} ({sourceFilePath}:{sourceLineNumber}): {message}");
}
LogMessage("Hello"); // "LogMessage (Program.cs:10): Hello"
```
### C# 6.0 (2015)
 * 式形式の関数メンバー
 * Null条件演算子 (?.)
 * 文字列補間 ($"{}")
 * 例外フィルター
 * nameof演算子
 * インデックス初期化子
 * 静的usingディレクティブ
```csharp
// 式形式の関数メンバー
int Square(int x) => x * x;

// Null条件演算子
string name = person?.Name; // personがnullの場合、nullを返す

// 文字列補間
string name = "John";
string message = $"Hello, {name}!"; // "Hello, John!"

// 例外フィルター
try { /* ... */ }
catch (Exception ex) when (ex.Message.Contains("特定のエラー")) { /* ... */ }

//nameof演算子
string nameOfVar = nameof(name);  // "name"

//インデックス初期化子
var dictionary = new Dictionary<int, string>
{
    [1] = "one",
    [2] = "two",
};

//静的usingディレクティブ
using static System.Math;
double result = Cos(PI);
```
### C# 7.0 (2017)
 * タプル
 * 分解 (Deconstruction)
 * パターンマッチング
 * ローカル関数
 * ref戻り値とrefローカル変数
 * 破棄 (_)
 * out変数宣言の簡略化
 * 数値リテラルの構文改善
```csharp
// タプル
(string name, int age) person = ("John", 30);
Console.WriteLine(person.name); // "John"

// 分解
(string name, int age) = person;
Console.WriteLine(name); // "John"

// パターンマッチング
if (obj is string s)
{
    Console.WriteLine(s.Length);
}

// ローカル関数
int Add(int x, int y)
{
    return x + y;
}
int result = Add(1, 2);

// ref戻り値とrefローカル変数
ref int GetValue(int[] array, int index)
{
    return ref array[index];
}
int[] numbers = { 1, 2, 3 };
ref int value = ref GetValue(numbers, 1);
value = 10; // numbers[1]が10になる

// 破棄
(string name, _) = person; // 年齢を破棄

// out変数宣言の簡略化
if (int.TryParse("123", out int number))
{
    Console.WriteLine(number);
}

// 数値リテラルの構文改善
int binary = 0b1010; // 2進数リテラル
int million = 1_000_000; // 区切り文字
```

### C# 7.1, 7.2, 7.3
細かい機能追加とコンパイラの改善が主。
 * 7.1: defaultリテラル、推論されたタプル要素名
 * 7.2: ref readonly、in引数
 * 7.3: ref再代入、式ツリーでのタプルサポート

### C# 8.0 (2019)
 * Null許容参照型
 * 非同期ストリーム (IAsyncEnumerable<T>)
 * using宣言
 * 静的ローカル関数
 * null合体代入演算子 (??=)
 * switch式の拡張
 * 再帰パターン
```csharp
#nullable enable // プロジェクトまたはファイル内でNull許容参照型を有効にする
string? nullableName = null; // null許容参照型
string nonNullableName = "John";

// 非同期ストリーム
async IAsyncEnumerable<int> GenerateSequenceAsync()
{
    for (int i = 0; i < 10; i++)
    {
        await Task.Delay(100);
        yield return i;
    }
}
await foreach (int number in GenerateSequenceAsync())
{
    Console.WriteLine(number);
}

// using宣言
using var file = new StreamReader("file.txt");
// file.Dispose()がスコープを抜けるときに呼ばれる

// null合体代入演算子
string? name = null;
name ??= "John"; // nameがnullの場合、"John"を代入

// switch式の拡張
string message = value switch {
    1 => "one",
    2 => "two",
    _ => "other"
};

// 再帰パターン
int Factorial(int n) => n switch {
    0 => 1,
    _ => n * Factorial(n - 1)
};
```
### C# 9.0 (2020)
 * レコード
 * initアクセサー
 * トップレベルステートメント
 * パターンマッチングの拡張
 * 関数ポインター
 * モジュール初期化子
 * ターゲットを絞ったnew式
 * 静的匿名関数
 * 共変の戻り値の型
```csharp
// レコード
public record Person(string Name, int Age);
Person person = new Person("John", 30);
Console.WriteLine(person); // "Person { Name = John, Age = 30 }"

// initアクセサー
public class MyClass
{
    public int MyProperty { get; init; }
}
MyClass obj = new MyClass { MyProperty = 10 };
// obj.MyProperty = 20; // エラー：initアクセサーは初期化時のみ設定可能

// トップレベルステートメント
// Program.csに以下のように書ける
Console.WriteLine("Hello, world!");

// パターンマッチングの拡張
if (obj is Person { Name: "John", Age: 30 }) { /* ... */ }

//関数ポインター
unsafe
{
    delegate*<int, int, int> add = &Add;
    int result = add(1, 2);
}
int Add(int a, int b) => a + b;
```
### C# 10.0 (2021)
 * レコード構造体
 * 名前空間スコープの宣言
 * グローバルusingディレクティブ
 * ファイル スコープの名前空間
 * ラムダ式の改良
 * 拡張パターン
 * const文字列補間
 * 混合構造体の割り当て
 * ジェネリック属性
```csharp
//レコード構造体
public record struct Point(double X, double Y);

//名前空間スコープの宣言
namespace MyNamespace; // このファイル内のすべての型がこの名前空間に属する
class MyClass { }

//グローバルusingディレクティブ
// 例えば、GlobalUsings.cs というファイルに以下を記述
global using System;
global using System.Collections.Generic;

//ラムダ式の改良
var multiply = (int a, int b) => a * b; // 型推論が向上

//拡張パターン
if (e is IEnumerable<int> { Count(): >= 3 })

//const文字列補間
const string name = "Bill";
const string message = $"Hello, {name}!";

//ジェネリック属性
public class MyAttribute<T> : Attribute { }
[MyAttribute<int>]
public class MyClass { }
```

### C# 11.0 (2022)
 * 必須メンバー
 * 自動既定構造体
 * ジェネリック算術サポート
 * UTF-8 文字列リテラル
 * リスト パターン
 * 生の文字列リテラル
 * 数値 IntPtr および UIntPtr
 * 関数ポインターの向上
```csharp
// 必須メンバー
public class MyClass
{
    public required string Name { get; set; }
}
// var obj = new MyClass(); // コンパイルエラー: Nameプロパティが設定されていない
var obj = new MyClass { Name = "John" };

//生の文字列リテラル
string str = """
    {
        "name": "John",
        "age": 30
    }
    """;

//リストパターン
int[] numbers = { 1, 2, 3 };
if (numbers is [1, 2, 3]) { }
if (numbers is [1, _, >=3]) { }
```

### C# 12.0 (2023)
 * コレクション式
 * インライン配列
 * ラムダ式の引数の既定値
 * エイリアスディレクティブの拡張
 * 実験的な属性
```csharp
// コレクション式
int[] arr = [1, 2, 3];  // int[]
int[] arr2 = [1, 2, 3, ..arr]; // int[]
Span<int> span = [1, 2, 3];    // Span<int>
List<int> list = [1, 2, 3];    // List<int>

// インライン配列
[System.Runtime.CompilerServices.InlineArray(10)]
public struct MyBuffer
{
    private int _element0;
    public int this[int index]
    {
        get { return _element0; } // 本来はオフセット計算が必要だが、簡略化
        set { _element0 = value; }
    }
}

// ラムダ式の引数の既定値
var greet = (string name = "World") => $"Hello, {name}!";
greet();          // "Hello, World!"
greet("John");    // "Hello, John!"

// エイリアスディレクティブの拡張
using System.Text.Json;
using j = System.Text.Json; // jというエイリアスで使えるようになる
```
このドキュメントでは、C#の主な機能の進化を概説し、それぞれのバージョンでの新機能とサンプルコードを提供しました。

